package Leetcode;

import java.util.Stack;

/**
 *此方法超时
 */
/*
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
 */
public class Demo32 {
    static int maxLength = 0;

    public static int longestValidParentheses(String s) {
        if (s.length() < 2) return 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i)==')') continue;
            int j = i + 1;
            for (; j < s.length(); j += 2) {
                if (s.length() - 1 - i <= maxLength) return maxLength;
                if (s.charAt(j)=='(') continue;
                boolean tem = isValid(s.substring(i, j + 1));
                if (tem && j + 1 - i > maxLength) maxLength = j + 1 - i;
            }
        }
        return maxLength;
    }

    public static boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char temp : s.toCharArray()) {
            //找到左括号，压入右括号
            if (temp == '(')
                stack.push(')');
                //其余判断不匹配情况，1.栈空，2,出栈元素不是当前元素
            else if (stack.isEmpty() || temp != stack.pop()) return false;
        }
        return stack.isEmpty();
    }

    public static void main(String[] args) {
        int i = longestValidParentheses("))))())(())()))(()()(())(())()))(((()()))()()))(())(())()())()(()())((()(((())()())(()())(())((()))))())()))()(())))())()))(()))((()())((()(())))(()))))))))((())(()()((())()()(()))))(((()(())))())))()())))())()()())()(())()(((())()))()()())))()())))()((((((())((())))((())())(((()())())()((((((()())((()()(())(()))(()())()))()(()(()())(()))((())((())))))()()))))()())()))))((((())(())))((()))(()()()()()((())((((())())()())()())(()(()()))())(((()())(()))()))(())()((()(())))))()())())()()(())))((())()()()))(())((()())))))((()((((()(((())()))))(()))()()))(()(())(()((()()()))))()))()()(((()()(())())()(())(()()()))()(()())))()((()((()))))())()(())()(()()((()()())(((())((())))(()())))()))()()())()))((()))(((()()()((()))))()()()))()))())())))))())()))(()))))(()()()))()((())))((())))()))(()()()()()()(()))())())(((())))(())(()(()())((()()()()))()()(()()))(()())(()()()((()()(((()(()((()((((()((())((()()))))))()())())(()(())()((((()()()()()))))()())()((())))))))()(((()())))()(()()(()()()()))()((((()((())(())))())))(()()()())()))))))((()))())((())(()(()(((()()()((((()()))())()())()())()))))())()(((()))))()()())))(())())))(())())((()))(())))(((()()))((((()))(()()))())((()())(()))(()(())(()(()))((((((()()(()()(()))()(()(())((((((((()(()())((())))())()())(()(()()))))(()(()()()))(()((()(((())((())(())()(()()())(()))())((()((((((())())(())()(()()(()())(())())()()))())(()))(())))()())))()()((()))())()()(())(()())()())())())))()()))((((()((()(())(((())()((())(())())))))()(()))())()))())(((())))))((((()(()()))))(((())(((())((())))))()()))()(()(((((((()))))((()))())()(())()))())())((()))))((())(())))(((())((((()(())(())()(((((())))()))()(()())(()()(())()(((()))())())))()))()()())((");
        System.out.println(i);
    }
}
